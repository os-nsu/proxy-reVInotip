# Proxy template



## Компиляция и линковка (lab1)

#### Теоретические вопросы
    1. Из каких этапов состоит компиляция (используйет флаги компилятора и посмотрите промежуточные результаты)?
    2. Что такое elf файл и какие его типы бывают?
    3. Используйте readelf. Посмотрите основные секции elf файла и их назначение.
    4. Статические и динамические библиотеки. Чем отличаются relocateable и shared object файлы.
    5. Как именно происходит подключение символов из динамической библиотеки (секции got, plt).
    6. Различие статической и динамической линковки (посмотрите dlopen и dlsym).
    7. nm и ldd, с какимии секциями elf файла работают? Объяснить вывод.
    8. Как устроена утилита file. Объяснить её вывод.
    9. Чем отличаются секции от сегментов?
    10. Посмотрите зависимости собранного исполняемого файла. Зачем нужен ld-linux.so (секция .interp)?
    11. Зачем может понадобиться утилита strip и objdump?
    12. Как запускается main функция программы?
    13. Зачем нужен флаг компиляции -export-dynamic
    14. При помощи nm посмотрите все символы получившегося исполняемого файла. Как настроить компоновщик, чтобы сохранились
        все символы, предоставляемые библиотекой config?

#### Задания (порядок выполнения не важен)
    1. Система плагинов:
        a. Напишите тестовый плагин с именем "greeting" в соответсвии с представленным интерфейсом (файл динамической библиотеки плагина должен называться так: "название плагина".so);
        b. Реализуйте все 3 функции плагина:
            - init должна подключать call-back функцию executor_start_hook и писать в stdout "greeting initialized"
            - fini должна отключать executor_start_hook и писать в stdout "greeting finished"
            - name должна возвращать "greeting"
            Кастомная функция executor_start_hook должна писать в stdout "Hello, world!"
        c. Реализуйте модуль мастер процесса, способный загружать и выгружать плагины во время работы программы;
            Вызовите executor_start_hook в main. Для демонстрации работы подключите плагин с именем "greeting", пока hardcode.
    2. Написать статическую библиотеку конфига в соответсвии с интерфейсом:
        a. Реализуйте из него функцию (и только её) int create_config_table(void). Она должна просто возвращать ноль и не делать больше ничего.
    3. Написать динамическую библиотеку логгера в соответствии с интерфейсом:
        b. Реализуйте из него функцию (и только её) int init_logger(char* path, long file_size_limit, int files_limit).
            Она должна просто возвращать ноль и не делать больше ничего, реализовывать проверку аргументов пока не требуется.

#### Архитектурные требования

    Для сборки нужно использовать мейкфайлы и утилиту make. При этом необходимо настроить проброс переменнных окружения
    CCFLAGS, CFLAGS, COPT, CPPFLAGS, LDFLAGS. Это необходимо для того, чтобы система тестирования могла собрать проект с санитайзерами.

    Все собранные библитеки, плагины и исполняемый файл должны находиться в папке
    install в корневой дирректории проекта. При этом для плагинов в папке install должна быть создана отдельная папка plugins.
    Создание папок должно происходить автоматически при сборке проекта.

#### Интерфейс и струтура проекта

    Весь необходимый итерфейс и структура проекта наглядно представлены в данной ветке
    (у каждого плагина обязательно должны быть функции: void init(void), void fini(void), const char *name(void)).

## Файлы и системные вызовы (lab2)
Лабораторная работа проверяет знания студентов по темам: системные вызовы, файловые системы.

#### Теоретические вопросы
    1. Системные вызовы и механизм их работы.
    2. Что такое файл? Чем отличается файл от дирректории?
    3. Что такое inode и dentry? Их основные поля и зачем они нужны?
    4. Символьные и жесткие ссылки и инструменты для их создания (symlink(2) и link(2)).
    5. Что выводит утилита strace? Используйте её вместе с библиотекой для времени, объясните что происходит.
    6. Зачем нужно vdso?
    7. Что такое файловая система?
    8. Утилиты mount и unmount. Что они делают и зачем нужны?

#### Задания (порядок выполнения не важен)
    1. Логгер:
        a. Реализуйте динамическую библиотеку логгера с указанным в файле pwd/src/include/config.h интерфейсом.
        Сообщение логгера должно иметь следующую сигнатуру: "TIME(UTC) FILE LINE [PID] | LEVEL: MESSAGE".
        При реализации учтите возможные способы передачи пути к дирректории с лог файлами (см. раздел "Команды для запуска
        и окружение"). Если путь к папке с логами не был передан ни одним из способов, то используйте stderr для вывода сообщений.
    2. Конфиг:
        a. Реализуйте статическую библиотеку системы конфигурации с указанным в файле pwd/src/include/config.h интерфейсом.
           При реализации учтите возможные способы передачи пути к файлу с конфигурацией (см. раздел "Команды для запуска
            и окружение"). Если путь к файлу с конфигурацией не был передан ни одним из способов, то ищите файл с
            конфигурацией в корневой дирректории проекта (он должен называться proxy.conf). Если по этому пути файла не оказалось,
            то используйте стандартные зангчения для необходимых переменных.
        b. Конфиг должен поддерживать параметры, указанные в разделе "Параметры конфигурации".
        c. Должна быть выстроена система приоритетов: Файл конфигурации < Переменная окружения < Опция командной.
           Значения параметров из источника с большим приоритетом перекрывают значения из источника с меньшим приоритетом.
        b. Используйте логгер для вывода сообщений об ошибках и трассировки
    3. Время
        a. Реализуйте статическую библиотеку для времени с указанным в файле pwd/src/include/my_time.h интерфейсом.
            Для этого используйте системный вызов time(2).
        b. Используйте получившеюся библиотечную функцию в логгере для получения времени.
    4. Версионирование библиотеки для времени
        a. Сохраните текущую версию библиотеки для времени и напишите новую реализацию, использующую свою обёртку над
            системным вызовом time (используйте syscall(2) из libc).
        b. Сделайте ещё одну реализацию этой библиотеки. Для этого разберитесь как работает syscall(2) и
            сделайте системный вызов без его помощи (используйте ассемблерные вставки).
        c. Для переключения между этими реализациями используйте символьные ссылки (.so файл библиотеки (с названием libtime.so)
            должен быть символьной ссылкой на одну из версий библиотеки).
    5. Модифицируйте систему загрузки плагинов из первой лабораторной так, чтобы она загружала плагины,
        названия которых ей переданы через конфигурацию или переменную окружения (см. раздел "Команды для запуска и окружение")
    6. Бекап логов
        a. Напишите плагин, который будет создавать жесткие ссылки на лог файлы в резервной директории с названием log_backup
            (она должна быть расположена на том же уровне, что и основная дирректория с логами).

#### Архитектурные требования

    Для сборки нужно использовать мейкфайлы и утилиту make. При этом необходимо настроить проброс переменнных окружения
    CCFLAGS, CFLAGS, COPT, CPPFLAGS, LDFLAGS. Это необходимо для того, чтобы система тестирования могла собрать проект с санитайзерами.

    Все собранные библитеки, плагины и исполняемый файл должны находиться в папке
    install в корневой дирректории проекта. При этом для плагинов в папке install должна быть создана отдельная папка plugins.
    Создание папок должно происходить автоматически при сборке проекта.

#### Интерфейс и струтура проекта

    Весь необходимый итерфейс и структура проекта наглядно представлены в данной ветке
    (у каждого плагина обязательно должны быть функции: void init(void), void fini(void), const char *name(void)).

#### Команды для запуска и окружение

    Передача пути к файлу с конфигурацией возможна двумя способами:
        1. Через флаг -c при запуске. (--config)
        2. Через переменную окуржения CONFIG_PATH

    Передача пути к дирректории для логов возможна двумя способами:
        1. Через флаг -l при запуске. (--logs)
        2. Через переменную окуржения LOG_DIR_PATH

    Передача списка плагинов для загрузки возможна двумя способами:
        1. Через список строк в конфигурации
        2. Через переменную окружения MASTER_PLUGINS (разделителем между названиями выступает запятая)

    Команда для запуска:
        pwd/install/proxy -c path_to_config_file -l path_to_log_dir

    Флаги могут идти в любом порядке и являются опциональными


#### Конфигурационные параметры

    log_file_size_limit=1024 # Максимальный размер лог файла в Kb
    log_dir="logs" # Путь до директории с лог файлами от pwd
    plugins=["test", "task_manager"] # Список плагинов

## Процессы (lab3)

#### Теоретические вопросы
    1. Что такое fork(2) и что он делает?
    2. Что такое clone(2) и что он делает?
    3. Состояния процесса. Состояние zombie и зачем оно нужно?
    4. Как получить код возврата процесса и что этот код из себя представляет?
    5. Что находится в proc, proc/stat?
    6. Процесс init, зачем он нужен.
    7. Что происходит с дочерними процессами, если родительский умирает?
    8. Сигнал SIGCHLD. Зачем он нужен и в каких случаях приходит?

#### Задания (порядок выполнения не важен)
    1. Реализовать функцию void register_worker(...) в соответсвии с интерфейсом.
        a. Эта функция должна создавать процесс, который начнёт выполнятся с переданной ему функции.
        b. Параметры, которые в неё передаются, должны быть где-то сохранены вместе с pid-ом процесса и
            удалены только при его окночательном завершении.
        c. Основной процесс должен посылать сигнал SIGTERM своим дочерним процессам при завершении.
            Коды возврата дочерних процессов должны корректно обрабатываться.
    2. Написать плагин с названием task_manager, использующий функцию register_worker для создания процесса.
        a. Функция, которая будет запущена в новом процессе должна просто возвращать ноль.
        b. Напишите обработчик сигнала SIGTERM так, чтобы при получении этого сигнала код возврата был 0.

#### Требования к устойчивости

    Все ресурсы при заверешнии должны корректно освобождаться (в том числе при сбоях в работе),
    дочерние процессы должны восстанавливаться если это необходимо, должна быть корректная обработка сигналов.